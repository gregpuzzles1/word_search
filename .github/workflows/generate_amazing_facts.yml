name: Generate Amazing Facts (One Category)

on:
  workflow_dispatch:
    inputs:
      category:
        description: "Category folder slug under public/wordcache (e.g. music, science_math)"
        required: true
        type: string

permissions:
  contents: write
  id-token: write   # REQUIRED for GitHub OIDC ‚Üí AWS role

jobs:
  generate-amazing-facts:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # ‚úÖ Configure AWS creds using GitHub OIDC (recommended)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-west-2
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Generate facts JSON files for one category (AWS_IAM signed)
        shell: bash
        env:
          FUNCTION_URL: "https://gahlbpuxl3sxb26ygqm366nxey0oxigj.lambda-url.us-west-2.on.aws/"
          CATEGORY: ${{ inputs.category }}
          AWS_REGION: "us-west-2"
        run: |
          set -euo pipefail

          BASE_DIR="public/wordcache"
          CAT_DIR="${BASE_DIR}/${CATEGORY}"
          LABEL_TOPICS="${CAT_DIR}/label_topics.json"

          if [ ! -d "$CAT_DIR" ]; then
            echo "‚ùå Category folder not found: $CAT_DIR"
            exit 1
          fi

          if [ ! -f "$LABEL_TOPICS" ]; then
            echo "‚ùå Missing label_topics.json: $LABEL_TOPICS"
            exit 1
          fi

          echo "‚úÖ Category: $CATEGORY"
          echo "‚úÖ Reading: $LABEL_TOPICS"

          # Install tiny AWS SDK v3 signing deps (only on the runner, not in your repo)
          mkdir -p /tmp/signer && cd /tmp/signer
          npm init -y >/dev/null 2>&1
          npm install @aws-sdk/signature-v4 @aws-sdk/protocol-http @aws-sdk/hash-node @aws-sdk/credential-provider-node >/dev/null

          node <<'NODE'
          import fs from "fs";
          import path from "path";
          import { URL } from "url";

          import { SignatureV4 } from "@aws-sdk/signature-v4";
          import { HttpRequest } from "@aws-sdk/protocol-http";
          import { Hash } from "@aws-sdk/hash-node";
          import { defaultProvider } from "@aws-sdk/credential-provider-node";

          const FUNCTION_URL = process.env.FUNCTION_URL;
          const INPUT_CATEGORY = process.env.CATEGORY;
          const REGION = process.env.AWS_REGION || "us-west-2";

          const BASE_DIR = "public/wordcache";
          const CAT_DIR = path.join(BASE_DIR, INPUT_CATEGORY);
          const LABEL_TOPICS_PATH = path.join(CAT_DIR, "label_topics.json");

          const raw = fs.readFileSync(LABEL_TOPICS_PATH, "utf-8");
          const json = JSON.parse(raw);

          // Schema you showed:
          // { category: "music", topics: [{slug,label}, ...], ... }
          if (!json || typeof json.category !== "string" || !Array.isArray(json.topics)) {
            throw new Error(`Unexpected label_topics.json schema in ${LABEL_TOPICS_PATH}`);
          }

          const topics = json.topics
            .filter(t => t && typeof t.slug === "string" && typeof t.label === "string")
            .map(t => ({ slug: t.slug.trim(), label: t.label.trim() }))
            .filter(t => t.slug.length > 0 && t.label.length > 0);

          if (topics.length === 0) {
            throw new Error(`No valid topics found in ${LABEL_TOPICS_PATH}`);
          }

          console.log(`‚úÖ Found ${topics.length} topics`);

          // You wanted to send "category" and "label" info.
          // Lambda expects: { category, topics: [<labels...>] }
          const payload = {
            category: INPUT_CATEGORY,
            topics: topics.map(t => t.label),
          };

          // Map label -> slug for output file naming
          const labelToSlug = new Map(topics.map(t => [t.label, t.slug]));

          // ---- SigV4 sign and POST to the Lambda Function URL ----
          const url = new URL(FUNCTION_URL);
          const body = JSON.stringify(payload);

          const signer = new SignatureV4({
            credentials: defaultProvider(), // uses creds from aws-actions/configure-aws-credentials
            region: REGION,
            service: "lambda",
            sha256: Hash,
          });

          const unsignedReq = new HttpRequest({
            protocol: url.protocol,
            hostname: url.hostname,
            method: "POST",
            path: url.pathname + (url.search || ""),
            headers: {
              "content-type": "application/json",
              host: url.hostname,
            },
            body,
          });

          const signedReq = await signer.sign(unsignedReq);

          const res = await fetch(FUNCTION_URL, {
            method: signedReq.method,
            headers: signedReq.headers,
            body,
          });

          const text = await res.text();
          if (!res.ok) {
            throw new Error(`Lambda error HTTP ${res.status}: ${text.slice(0, 2000)}`);
          }

          let data;
          try {
            data = JSON.parse(text);
          } catch {
            throw new Error(`Lambda returned non-JSON: ${text.slice(0, 2000)}`);
          }

          if (!data || !Array.isArray(data.results)) {
            throw new Error(`Unexpected Lambda response shape: ${text.slice(0, 2000)}`);
          }

          console.log(`‚úÖ Lambda returned ${data.results.length} results`);

          // Write: public/wordcache/<category>/<slug>_facts.json
          for (const item of data.results) {
            const label = (item.topic ?? "").trim();
            const slug = labelToSlug.get(label);

            if (!slug) {
              console.warn(`‚ö†Ô∏è No matching slug for returned topic label: "${label}". Skipping.`);
              continue;
            }

            const outPath = path.join(CAT_DIR, `${slug}_facts.json`);
            fs.writeFileSync(outPath, JSON.stringify(item, null, 2) + "\n", "utf-8");
            console.log(`üìù Wrote ${outPath}`);
          }

          console.log("‚úÖ Done.");
          NODE

      - name: Commit and push changes (if any)
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "$(git status --porcelain)" ]; then
            echo "‚úÖ No changes to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add public/wordcache/${{ inputs.category }}/
          git commit -m "Generate amazing facts for ${{ inputs.category }}"
          git push

